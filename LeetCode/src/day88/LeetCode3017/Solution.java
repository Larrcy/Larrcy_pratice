package day88.LeetCode3017;

/**
 * 给你三个 正整数 n 、x 和 y 。
 * <p>
 * 在城市中，存在编号从 1 到 n 的房屋，由 n 条街道相连。对所有 1 <= i < n ，都存在一条街道连接编号为 i 的房屋与编号为 i + 1 的房屋。另存在一条街道连接编号为 x 的房屋与编号为 y 的房屋。
 * <p>
 * 对于每个 k（1 <= k <= n），你需要找出所有满足要求的 房屋对 [house1, house2] ，即从 house1 到 house2 需要经过的 最少 街道数为 k 。
 * <p>
 * 返回一个下标从 1 开始且长度为 n 的数组 result ，其中 result[k] 表示所有满足要求的房屋对的数量，即从一个房屋到另一个房屋需要经过的 最少 街道数为 k 。
 * <p>
 * 注意，x 与 y 可以 相等 。
 */
public class Solution {
    //题目要求(i,j)与(j,i)这两个房屋对都要统计
    //可以选择统计i<j的房屋对 然后对所有答案乘以2即可
    public long[] countOfPairs(int n, int x, int y) {
        //下面进行分类讨论
        //1.当i<=x时
        //I: 一定可以在[x,y]之间找到一个点k
        //使得从i到k的距离小于等于从i到x再从x到y再从y到k的距离
        //1----i----x--k--y----n
        //i----k<=i---x---y---k
        //即k-i<=x-i+1+y-k
        //整理不等式可得
        //k<=(x+y+1)/2
        //因此对于[i+1,k]的房子可以选择不走x-y这条路
        //因此将距离为[1,k-i]的结果集都+1
        //II: 对于[k+1,y-1]的房子可以利用x-y这条路到达
        //此时考虑的是[y,k+1]范围内的距离再加上x-i+1
        //因此将距离为[x-i+2,x-i+y-k]的结果集都+1
        //III: 对于[y,n]的房子也需要利用x-y这条路到达
        //此时考虑的是[y,n]范围内的距离再加上x-i+1
        //因此将距离为[x-i+1,x-i+1+n-y]的结果集+1
        //2.当x<i<(x+y)/2时
        //I:跟第一种情况类似
        //1---x---i---k--y----n
        //i----k<=i---x--y--k
        //即k-i<=i-x+1+y-k
        //即k<=i+(y-x+1)/2
        //因此对于[i+1,k]的房子可以选择不走x-y这条路
        //因此将距离为[1,k-i]的结果集都+1
        //II:对于[k+1,y-1]的房子可以利用x-y这条路到达
        //此时考虑的是[y,k+1]范围内的距离再加上i-x+1
        //因此将距离为[i-x+2,i-x+y-k]的结果集都+1
        //III:对于[y,n]的房子也需要利用x-y这条路到达
        //此时考虑的是[y,n]范围内的距离再加上i-x+1
        //因此将距离为[i-x+1,i-x+n-y]的结果集都+1
        //3.对于更大的i它的右侧房屋无法利用x-y这条边到达
        //因此只需要将[1,n-i]的结果集+1


        //保证y在x的右边
        if (x > y) {
            int temp = x;
            x = y;
            y = temp;
        }
        //记录结果集
        long[] ans = new long[n];
        //若x + 1 >= y则此时x-y这条路径对最短路无影响
        //直接收集结果即可
        if (x + 1 >= y) {
            for (int i = 1; i < n; i++) {
                ans[i - 1] = (n - i) * 2;
            }
            return ans;
        } else {
            int[] diff = new int[n + 1];
            for (int i = 1; i < n; i++) {
                //将上面分类讨论的情况进行代码实现
                if (i <= x) {
                    int k = (x + y + 1) / 2;
                    diff[1]++;
                    diff[k - i + 1]--;
                    diff[x - i + 2]++;
                    diff[x - i + y - k + 1]--;
                    diff[x - i + 1]++;
                    diff[x - i + 1 + n - y + 1]--;
                } else if (i < (x + y) / 2) {
                    int k = i + (y - x + 1) / 2;
                    diff[1]++;
                    diff[k - i + 1]--;
                    diff[i - x + 2]++;
                    diff[i - x + y - k + 1]--;
                    diff[i - x + 1]++;
                    diff[i - x + 1 + n - y + 1]--;
                } else {
                    diff[1]++;
                    diff[n - i + 1]--;
                }
            }
            //将差分数组累加进行还原
            long sum = 0;
            for (int i = 0; i < n; i++) {
                sum += diff[i + 1];
                ans[i] = sum * 2;
            }
        }
        return ans;
    }

}
