package day60.LeetCode260;

/**
 * 给你一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。
 */
public class Solution {
    /*
   分组异或
   1.所有数字异或的结果等于其中两个只出现1次数字异或的结果
   2.该异或结果至少一位为1，因为是两个不同的数字进行异或
     相同位得0 不同位得1
     则这个异或结果必定是一个为0另一个为1的组合
   3.以第一次出现1的位置位区分点，那么两个只出现1次的数字必定会被分到不同的组
     而均出现两次的数字会成对地分配到各自的组
   4.最后对分开的两组数分别进行异或操作即可得到只出现1次的数
    */
    public int[] singleNumber(int[] nums) {
    /*  例： 1 2 1 3 2 5
        对应的二进制数：
        1: 0 0 1
        2: 0 1 0
        1: 0 0 1
        3: 0 1 1
        2: 0 1 0
        5: 1 0 1
        所有数异或得结果：1 1 0
        从右到左找到第一个为1的位置
        因为只有两个数出现一次 其他都出现两次
        故出现1的这个位置必定可以分为两组
        分别对这两组数进行异或操作即可得到两个不同的数
        */
        int[] res = new int[2];
        int xor = 0;
        for (int num : nums) xor ^= num;
        int k = 0;
        while (((xor >> k) & 1) == 0) k++;
        // k会停留至首个xor为1的位上
        for (int num : nums) {
            if ((num >> k & 1) == 0) {
                res[0] ^= num;
            } else {
                res[1] ^= num;
            }
        }
        return res;
    }
}
