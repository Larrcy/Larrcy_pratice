package day70.树状数组.LeetCode2930;

/**
 * 给你一个整数 n 。
 * <p>
 * 如果一个字符串 s 只包含小写英文字母，且 将 s 的字符重新排列后，新字符串包含 子字符串 "leet" ，那么我们称字符串 s 是一个 好 字符串。
 * <p>
 * 比方说：
 * <p>
 * 字符串 "lteer" 是好字符串，因为重新排列后可以得到 "leetr" 。
 * "letl" 不是好字符串，因为无法重新排列并得到子字符串 "leet" 。
 * 请你返回长度为 n 的好字符串 总 数目。
 * <p>
 * 由于答案可能很大，将答案对 109 + 7 取余 后返回。
 * <p>
 * 子字符串 是一个字符串中一段连续的字符序列。
 */
public class Solution {
    //容斥原理+快速幂
    //正难则反。总共26^n个字符串，减去不含 leet 的字符串个数，就得到了答案。
    //不含 leet 的字符串，需要至少满足如下三个条件中的一个：
    //1.不含 l。
    //2.不含 t。
    //3.不含 e 或者恰好包含一个 e。

    //至少满足一个条件
    //不含 l：每个位置可以填 25 种字母，方案数为25^n

    //不含 t：方案数为25^n

    //不含e或者恰好包含一个e：
    //不含e方案数为25^n
    //恰好包含一个e：
    //先从n个位置中选一个填 e，然后剩下 n−1位置不能包含 e
    //方案数为 n*25^(n-1)
    //加起来就是 (3*25+n)*25^(n-1)
    //这样重复统计了「至少满足两个条件」的情况，要减去。

    //至少满足两个条件
    //不含 l 和 t：每个位置可以填 24种字母，方案数为 24^n

    //不含 l 且 e 的个数不足两个：方案数为 24^n+n*24^(n-1)

    //不含 t 且 e 的个数不足两个：方案数为 24^n+n*24^(n-1)

    //加起来就是 (3*24+2n)*24^(n−1)
    // 这样就重复统计了「满足三个条件」的情况，要减去。

    //满足三个条件
    //同「满足一个条件」中 3 的分析，额外不能填 l 和 t，方案数为 23^n+n*23^(n−1)
    //最后用26^n减去不含 leet 的字符串的个数，得到答案：
    //26^n-(3*25+n)*25^(n-1)+(3*24+2n)*24^(n−1)-23^n+n*23^(n−1)

    long MOD = (long) 1e9 + 7;
    public int stringCount(int n) {
        return (int) (((pow(26, n)
                - pow(25, n - 1) * (75 + n)
                + pow(24, n - 1) * (72 + n * 2)
                - pow(23, n - 1) * (23 + n)) % MOD + MOD) % MOD); // 保证结果非负
    }

    //快速幂模板
    private long pow(long x, int n) {
        long res = 1;
        for (; n > 0; n /= 2) {
            if (n % 2 > 0) {
                res = res * x % MOD;
            }
            x = x * x % MOD;
        }
        return res;
    }
}
